<?xml version="1.0" encoding="utf-8" ?>
<Course xmlns="http://angulartutorial.azurewebsites.net/Course.xsd">
  <Module Id="module-getting-started" Title="Getting Started">
    <Lesson Id="the-essentials" Title="The Essentials">
      <Instructions>
        <![CDATA[
##What is AngularJS?
AngularJS is a JavaScript framework that is used for making rich, extensible web applications. It runs on plain JavaScript and HTML, so you don't need any other dependencies to make it work, and it is CSS-agnostic so you can use whatever CSS framework/methodology you want when designing your Angular application.

##What does an Angular app look like?
The code at the right is an example of a "hello world" Angular app. When run, "Hello World!" is printed onscreen using AngularJS. Don't worry too much about understanding the code just yet. We'll work through this example step-by-step in the next lesson.

##How is an Angular app architectured?
Angular applications at their most basic consist of three components.

###The template

The template is the HTML portion of the app. Writing a template is exactly like writing a static HTML page, except that templates contain additional syntax which allows data to be injected into them in order to provide a customized user experience. If you have ever written an HTML page using a server-side web framework you'll feel right at home writing templates in Angular. The feature that differentiates Angular templates from server-generated pages, however, is that in Angular data can be injected, modified and removed from templates without ever requiring a page refresh. This feature provides a more fluid experience to the end user and enhances the overall feel of Angular web applications.

###The scope

The scope is a very important component in Angular applications. The scope is the object that represents the "model" of your application. It contains fields that store data which is presented to the user via the template, as well as functions which can be called when the user performs certain actions such as clicking a button.

###The controller

The controller plays somewhat of a supporting role in Angular applications. The controller is a function which generally takes an empty scope object as a parameter and adds to it the fields and functions that will be later exposed to the user via the view.

##Relation to MVC
Up until now I have intentionally tried to stay away from making any comparisons between Angular and MVC for the benefit of those who have not worked with the MVC pattern before. If you have worked with MVC, then you probably won't need any help in identifying how closely Angular's architecture resembles that of an MVC-based application. As the two are so closely linked, I may from here on in refer to the template as the "view" and the scope as the "model". If you are unfamiliar with MVC, just be aware that these terms are interchangeable and that I am not talking about anything that you haven't seen before.

##Summary
The template, the scope, and the controller are the three main building blocks of an Angular web application. While there is much more to Angular than these three components, with an understanding of what they do and how they interact you will already be capable of wiring together a simple Angular application.
      ]]>
      </Instructions>
      <Html>
        <Document Name="index.html">
          <Initial>
            <![CDATA[
<html ng-app="root">
    <body>
        <div ng-controller="index">{{message}}</div>
    </body>
</html>
          ]]>
          </Initial>
          <Solution>
            <![CDATA[
<html ng-app="root">
    <body>
        <div ng-controller="index">{{message}}</div>
    </body>
</html>
          ]]>
          </Solution>
        </Document>
      </Html>
      <JavaScript>
        <Document Name="root.js">
          <Initial>
            <![CDATA[
angular.module('root', [])
    .controller("index", ["$scope", function ($scope) {
        $scope.message = "Hello World!";
    }]);
            ]]>
          </Initial>
          <Solution>
            <![CDATA[
angular.module('root', [])
    .controller("index", ["$scope", function ($scope) {
        $scope.message = "Hello World!";
    }]);
            ]]>
          </Solution>
        </Document>
      </JavaScript>
    </Lesson>
    <Lesson Id="a-simple-app" Title="A Simple App">
      <Instructions>
        <![CDATA[
*These lessons are intended to be interactive. Follow along in the code pages on the right as we go!*

---

Now that we have a basic understanding of what Angular is all about and how an application fits together, let's jump right in and integrate Angular into a simple web page.

##Writing the controller
For this lesson we are starting out with a very basic web page which contains a single, empty `<div>`. Let's use Angular to insert the text "Hello World" dynamically into the page.

The first thing that we need to do is define our controller. Remember, the controller is a function which augments the scope with data, functions, and whatnot.

To define our controller we first need to define what is known as a *module*. We didn't discuss modules in the last lesson, but no need to worry; they are extremely simple to understand. Modules act as logical containers for components in Angular applications. Whenever we define a component such as a controller, it needs to go in a module. The syntax for defining a module is as follows.

	angular.module("root", [])

That's all there is to it! The first argument, the string, defines the name of the module, which in this case is `root`. The second argument, the empty array, is used for dependency injection. We aren't going to get into Angular's dependency injection mechanism quite yet, but if you are unfamiliar with the concept of DI I strongly  recommend that you at least get acquainted with the concept before continuing on.*

Anyways, in this example we don't need to inject any dependencies into our module, so the array is empty. Now, I must stress the following point because it is a common place for beginners to trip up when declaring modules. **Do not forget the empty array**. If you forget it, Angular will try to retrieve an existing module for you instead of instantiating a new one and an error will be thrown.

Anyways, now that we have declared our module we can move on to declaring our controller. We declare our controller directly on the module that we have just created by using the `controller()` function like so.

	angular.module("root", [])
		.controller("index", ["$scope", function($scope) {
			
		}]);

The controller function syntax is much like the module syntax. The first argument specifies the name of the controller we are declaring. The second argument is an array whose last argument is a function. This is the controller function that we will use to augment our scope.

The elements in the array that precede the controller function are the names of the dependencies that we will  pass to the function as arguments. In this case, we are passing the `$scope` dependency into the controller. This is the scope to which we will add our functions and variables in just a moment. It is important to note that the order of dependencies in the array must match the order of the function arguments.

##Augmenting the $scope

Now that our controller function is defined, we can start working on the `$scope`. Let's define a variable named `message` which will contain the string `Hello World!`

	angular.module("root", [])
		.controller("index", ["$scope", function($scope) {
			$scope.message = "Hello World";
		}]);

Great. Now all we need to do is wire up our template to display this value in the empty `div`.

##Putting it all together.

Let's turn our attention to our HTML. For now we just have a simple page. We need to do five things to wire in Angular.

1. Include a reference to the Angular script file.
2. Include a reference to our controller script file.
3. Tell Angular which module we are using as our "root module"
4. Tell Angular to what part of the page it should apply our controller and the corresponding scope.
5. Tell Angular to display our message in the `<div>`.

For this lesson and throughout this entire site in fact, I have already taken care of steps 1 and 2 for you behind the scenes. In upcoming lessons I will often take care of step 3 for you as well. However in this lesson steps 3, 4, and 5 are up to you!

###The root module

In Angular-speak, the "root module" is the base module for the application. In our case we only have one module so the selection process is easy. We need to tell Angular that we want the `root` module to be our root. We do this by adding what is known as a *directive* to the `html` element of the page. You'll be hearing a lot about directives as we go on. Directives are essentially instructions that we use to tell Angular what we want it to do.

The directive we need to apply is the `ngApp` directive. We apply this directive to the HTML element in the form of an attribute, like so.

	<html ng-app="root">

There are a couple things to note here.

+ The directive name is `ngApp` but it is applied in the form of an attribute named `ng-app`. We'll discuss the intricacies of this syntax in a later lesson, but for now just understand that directives are given names in camelCase but are written in hyphen-delimited lowercase when applied as attributes.

+ The value of the attribute is the name of our root module.

That's all we need to do. Angular now understands that the module named `root` is the root module for the application.

###The controller

We now need to apply our controller to the page. We apply the controller using the `ngController` directive. The element to which we apply the `ng-controller` attribute is important. This element and all its children will be able to access the `$scope` object augmented by the controller.

For this lesson, we are going to apply the directive to the `div` element like so.

	<div ng-controller="index"></div>

###Accessing the scope

All that's left to do is display our message in the page! To print a variable value in our template, we use the double curly brace syntax, specifying the name of the `$scope` variable we wish to print.

	{{message}}

Add this syntax to the `<div>` element on which we applied our controller and run the code. If all is well, you should see `Hello World` printed loud and clear onto the page for all to see! If something went wrong, don't worry. You can either see the answer by clicking on the "I'm stuck!" button, or reset the example altogether and start over.

##Expressions
Now that you've seen how to bind a scope value to the template, try this. Replace `{{message}}` with a mathematical equation such as `{{1 + 1}}` and run the application. You'll see that Angular will have evaluated the equation and printed the result! This is because the value inside the curly braces is considered by Angular to be an *expression*. Expressions are like simple JavaScript statements, which means that in addition to supporting `$scope` fields, they also support simple functions like this one. Details of exactly what is and is not supported by Angular expressions can be found [here on the Angular site](http://docs.angularjs.org/guide/expression).

##Summary
We learned a lot this lesson! We learned about modules, how to declare controllers, and most importantly how to wire everything together to make a full-fledged application. While we haven't seen anything very impressive in terms of results, don't worry because we're getting there. In the next set of lessons we'll take a deeper look at directives and how they can enrich Angular applications.

---

\* [Dependency injection for five year olds](http://stackoverflow.com/a/1638961/1068266) is a good place to start if you are completely unfamiliar with the concept, after which there is [this explanation which is simple and to the point](http://www.jamesshore.com/Blog/Dependency-Injection-Demystified.html).
      ]]>
      </Instructions>
      <Html>
        <Document Name="index.html">
          <Initial>
            <![CDATA[
<!DOCTYPE html>
<html>
    <body>
        <div></div>
    </body>
</html>
          ]]>
          </Initial>
          <Solution>
            <![CDATA[
<html ng-app="root">
    <body>
        <div ng-controller="index">{{message}}</div>
    </body>
</html>
          ]]>
          </Solution>
        </Document>
      </Html>
      <JavaScript>
        <Document Name="root.js">
          <Initial></Initial>
          <Solution>
            <![CDATA[
angular.module('root', [])
    .controller("index", ["$scope", function ($scope) {
        $scope.message = "Hello World!";
    }]);
            ]]>
          </Solution>
        </Document>
      </JavaScript>
    </Lesson>
  </Module>
  <Module Id="module-basic-directives" Title="Basic Directives">
    <Lesson Id="two-way-bindings" Title="Two-way bindings">
      <Instructions>
        <![CDATA[
In this section we are going to take a look at some basic directives that you can use to add interactivity and flexibility to your web applications. There is a lot more to the Angular framework than we have just seen, but looking at a few directives right away will give you an idea of what you can do with Angular and hopefully inspire you to learn more about the framework in the sections that follow.

##ngModel

We're going to start out by looking at one of the most important directives in Angular, `ngModel`. Unlike values bound using the double curly brace syntax, `ngModel` allows us to bind values to HTML elements such as input fields. When using `ngModel`, not only are changes in the scope reflected in the view, but changes in the view are reflected back into the scope.

##Example

To see `ngModel` in action, we are going to use it to bind the `favoriteWord` field in the scope to the input field in the HTML page. To do this, we simply need to apply `ngModel` to the input field in the form of an attribute like so.

`<input type="text" ng-model="favoriteWord" />`

As you can see, `ngModel` takes an expression which is almost always the name of the `$scope` field to which we want to bind our element. Now, go ahead and try binding the other two scope variables to their respective input fields. As a reminder, remember that radio button values are retrieved from each individual `<input>` tag, and that drop-down values are retrieved from the all-encompassing `<select>` tag.

Once the values are bound, use the double curly brace syntax to display each value next to its corresponding input and run the example to see two-way binding in action!
        ]]>
      </Instructions>
      <Html>
        <Document Name="index.html">
          <Header>
            <![CDATA[
<!DOCTYPE html>
<html ng-app="root">
  <body>
            ]]>
          </Header>
          <Initial>
            <![CDATA[
<div ng-controller="index">
	<div>
		Favorite word: <input type="text" />
		- [Display selection here]
	</div>
	<div>
		Favorite color:
		<input type="radio" name="fc" value="Red">Red</input>
		<input type="radio" name="fc" value="Green">Green</input>
		<input type="radio" name="fc" value="Yellow">Yellow</input>
		<input type="radio" name="fc" value="Blue">Blue</input>
		- [Display selection here]
	</div>
	<div>
		Favorite shape:
		<select>
			<option value="Circle">Circle</option>
			<option value="Triangle">Triangle</option>
			<option value="Square">Square</option>
		</select>
		- [Display selection here]
	</div>
</div>
            ]]>
          </Initial>
          <Solution>
            <![CDATA[
<div ng-controller="index">
	<div>
		Favorite word: <input type="text" ng-model="favoriteWord" />
		- {{favoriteWord}}
	</div>
	<div>
		Favorite color:
		<input type="radio" name="fc" value="Red" ng-model="favoriteColor">Red</input>
		<input type="radio" name="fc" value="Green" ng-model="favoriteColor">Green</input>
		<input type="radio" name="fc" value="Yellow" ng-model="favoriteColor">Yellow</input>
		<input type="radio" name="fc" value="Blue" ng-model="favoriteColor">Blue</input>
		- {{favoriteColor}}
	</div>
	<div>
		Favorite shape:
		<select ng-model="favoriteShape">
			<option value="Circle">Circle</option>
			<option value="Triangle">Triangle</option>
			<option value="Square">Square</option>
		</select>
		- {{favoriteShape}}
	</div>
</div>      
            ]]>
          </Solution>
          <Footer>
            <![CDATA[
  </body>
</html>
            ]]>
          </Footer>
        </Document>
      </Html>
      <JavaScript>
        <Document Name="root.js">
          <Initial>
            <![CDATA[
angular.module("root", [])
    .controller("index", ["$scope", function($scope) {
        $scope.favoriteWord;
        $scope.favoriteColor;
        $scope.favoriteShape;
    }]);
            ]]>
          </Initial>
          <Solution>
            <![CDATA[
angular.module("root", [])
    .controller("index", ["$scope", function($scope) {
        $scope.favoriteWord;
        $scope.favoriteColor;
        $scope.favoriteShape;
    }]);
            ]]>
          </Solution>
        </Document>
      </JavaScript>
    </Lesson>
    <Lesson Id="binding-css-classes" Title="Binding CSS classes">
      <Instructions>
        <![CDATA[
Just as Angular lets us bind scope values to input fields, it also allows us to bind scope values as class names to HTML elements. As you can imagine, this feature is extremely useful and probably one of the most used features in Angular altogether.

##ngClass

To bind a CSS class to an HTML element, we use the `ngClass` directive. `ngClass` takes as input an expression which must evaluate to one of the following.

+ A string of space-delimited class names.
+ An array of class names.
+ A map (object) where the keys are class names and the values are boolean values indicating whether or not to apply the class.

##Example

For this demo, I've defined three CSS classes for you behind the scenes:

+ `bold`
+ `italic`
+ `underline`

Let's try applying these three classes to the `span` of sample text in the HTML window according to the following logic:

+ If the value in the textbox % 2 == 0, apply `bold`.
+ If the value in the textbox % 3 == 0, apply `italic`.
+ If the value in the textbox % 5 == 0, apply `underline`.

For this example, let's try to do this with a map.

We'll start by defining a function for each of the criteria in the controller.

	$scope.isBold = function () { return $scope.value % 2 === 0; };
	$scope.isItalic = function () { return $scope.value % 3 === 0; };
	$scope.isUnderlined = function () { return $scope.value % 5 === 0; };

Now, let's apply the `ngClass` directive to the span of text in the form of an attribute, and pass it a map of class names and boolean values.

	ng-class="{bold: isBold(), italic: isItalic(), underline: isUnderlined()}"

Once applied, run the program. When you change the number in the text field, the classes applied to the sample text should change accordingly.
        ]]>
      </Instructions>
      <Html>
        <Document Name="index.html">
          <Header>
            <![CDATA[
<!DOCTYPE html>
<html ng-app="root">
<head>
<style>
.bold {
	font-weight: bold;
}
.italic {
	font-style: italic;
}
.underline {
	text-decoration: underline;
}
</style>
</head>
<body>
            ]]>
          </Header>
          <Initial>
            <![CDATA[
<div ng-controller="index">
  <input type="text" ng-model="value" />
  <span>Example Text</span>
</div>
            ]]>
          </Initial>
          <Solution>
            <![CDATA[
<div ng-controller="index">
  <input type="text" ng-model="value" />
  <span ng-class="{bold: isBold(), italic: isItalic(), underline: isUnderlined()}">
	  Example Text
  </span>
</div>
            ]]>
          </Solution>
          <Footer>
            <![CDATA[
</body>
</html>
            ]]>
          </Footer>
        </Document>
      </Html>
      <JavaScript>
        <Document Name="root.js">
          <Initial>
            <![CDATA[
angular.module("root", [])
	.controller("index", ["$scope", function ($scope) {
		$scope.value = 1;
	}]);
            ]]>
          </Initial>
          <Solution>
            <![CDATA[
angular.module("root", [])
	.controller("index", ["$scope", function ($scope) {
		$scope.value = 1;
		$scope.isBold = function () { return $scope.value % 2 === 0; };
		$scope.isItalic = function () { return $scope.value % 3 === 0; };
		$scope.isUnderlined = function () { return $scope.value % 5 === 0; };
	}]);
            ]]>
          </Solution>
        </Document>
      </JavaScript>
    </Lesson>
    <Lesson Id="repeaters" Title="Repeaters">
      <Instructions>
        <![CDATA[
It often happens that you need to display a collection of data to the user. For this task, Angular provides you with the `ngRepeat` directive. `ngRepeat` gives you the power to define a template for a single item in a collection, and then have it be repeated for all the elements in a collection.

The syntax for `ngRepeat` is super easy. In attribute form, it looks like this.

`ng-repeat="element in collection"`

Where `collection` is a collection in scope and `element` is a variable used to reference each element throughout the iteration.

In addition to this, Angular exposes several variables that allow you to gain information about the element currently being iterated on.

+ `$index` - The index of the current element.
+ `$first` - Boolean indicating if the element is first in the collection.
+ `$middle` - Boolean indicating if the element is neither first nor last in the collection.
+ `$last` - Boolean indicating if the element is last in the collection.
+ `$even` - Boolean indicating if the element's index is even.
+ `$odd` - Boolean indicating if the element's index is odd.

These variables can be used freely within the scope of the iteration.

##Example

For this example, I've gone ahead and defined the CSS class `oddRow` behind the scenes. `oddRow` will change the background color of the element to which it is applied to a light gray color. What we're going to do in this example is populate the HTML table which is currently empty with the list of products defined in `root.js`.

The first thing to do is to define what we want one row of the table to look like. Let's do that now, filling in the empty `<tbody>` tag with a single row.


	<tbody>
		<tr>
			<td></td>
			<td></td>
		</tr>
	</tbody>

Great. Now let's add the repeat directive. It is important to understand that `ngRepeat` will repeat *itself and its contents* for each element in the collection. We must therefore apply it to the `<tr>` and not the `<tbody>`.

	<tbody>
		<tr ng-repeat="product in products">
			<td></td>
			<td></td>
		</tr>
	</tbody>

Let's now go ahead and populate the cells with the values from the collection objects.

	<tr ng-repeat="product in products">
		<td>{{product.id}}</td>
		<td>{{product.name}}</td>
	</tr>

Almost done! Now let's apply the `oddRow` class to every odd-indexed `<tr>`. We'll need to use the `ngClass` directive that we learned about in the last lesson for this.

	<tr ng-repeat="product in products" ng-class="{oddRow: $odd}">
		<td>{{product.id}}</td>
		<td>{{product.name}}</td>
	</tr>

We're done! Run the program and check out the results!
        ]]>
      </Instructions>
      <Html>
        <Document Name="index.html">
          <Header>
            <![CDATA[
<!DOCTYPE html>
<html ng-app="root">
<head>
<style>
.oddRow { background-color: lightblue; }
table { border-spacing: 0; }
td { border: 1px solid black; padding: 0 1em 0 1em; }
</style>
</head>
<body>
            ]]>
          </Header>
          <Initial>
            <![CDATA[
<div ng-controller="index">
  <table>
	  <thead>
		  <tr>
			  <td>Id</td>
			  <td>Name</td>
		  </tr>
	  </thead>
	  <tbody>
	  </tbody>
  </table>
</div>
            ]]>
          </Initial>
          <Solution>
            <![CDATA[
<div ng-controller="index">
  <table>
	  <thead>
		  <tr>
			  <td>Id</td>
			  <td>Name</td>
		  </tr>
	  </thead>
	  <tbody>
		  <tr ng-repeat="product in products"
			  ng-class="{oddRow: $odd}">
			  <td>{{product.id}}</td>
			  <td>{{product.name}}</td>
		  </tr>
	  </tbody>
  </table>
</div>
            ]]>
          </Solution>
          <Footer>
            <![CDATA[
</body>
</html>
            ]]>
          </Footer>
        </Document>
      </Html>
      <JavaScript>
        <Document Name="root.js">
          <Initial>
            <![CDATA[
angular.module("root", [])
	.controller("index", ["$scope", function($scope) {
		$scope.products = [
			{id: 1, name: "Hockey puck"},
			{id: 2, name: "Golf club"},
			{id: 3, name: "Baseball bat"},
			{id: 4, name: "Lacrosse stick"}
		];
}]);
            ]]>
          </Initial>
          <Solution>
            <![CDATA[
angular.module("root", [])
	.controller("index", ["$scope", function($scope) {
		$scope.products = [
			{id: 1, name: "Hockey puck"},
			{id: 2, name: "Golf club"},
			{id: 3, name: "Baseball bat"},
			{id: 4, name: "Lacrosse stick"}
		];
}]);
            ]]>
          </Solution>
        </Document>
      </JavaScript>
    </Lesson>
    <Lesson Id="visibility" Title="Visibility">
      <Instructions>
        <![CDATA[
##Showing and hiding

We've already seen that Angular lets you bind CSS classes to elements by way of the `ngClass` directive. However if you simply want to show or hide an element, there is a shortcut. The `ngShow` and `ngHide` directives display or hide an element from view by manipulating its `display` CSS property. They both take an expression as an argument which is expected to return a Boolean value.

##Adding and removing

If `ngShow` and `ngHide` control visibility, `ngIf` controls *existence*. That is to say that instead of simply altering how elements are displayed, `ngIf` adds and removes them from the DOM altogether. There are three important things to be aware of when using `ngIf`.

+ Code that performs calculations based on the position of elements in the DOM will behave differently with `ngIf` as opposed to `ngShow` or `ngHide`, as the latter two leave hidden elements in the DOM.

+ State is not preserved when Angular adds/removes elements from the DOM using `ngIf`. Elements that are removed from and then readded to the DOM are regenerated by Angular and reappear in their initial state, not the state that they were in when they were first removed.

+ Elements inserted with `ngIf` live in their own scope which inherits from their parent element's scope. In simple terms, this means that applying `ngIf` to an element is like applying a second `controller` directive. You will have access to the same fields as in the parent, but they will reside on a separate scope object. You therefore cannot rely on variables in one scope to remain synchronized with those in the other scope.*

##Example

For this example we're going to hook in the visibility of two `<div>` elements to two fields in our `$scope`. The fields are already declared for you, and two checkboxes are present to allow you to set each value. Try applying `ng-show="isFirstElementVisible"` to the first `<div>` and its `ngIf` equivalent to the second `<div>`. Then run the example and test it out. If you wish, you can take a look at the corresponding HTML for the document using your browser's development tools to see how `ngIf` and `ngShow` hide the elements to which they are applied.

---

*To see this in action, try pasting the following code into the editors and modifying the textbox values.

HTML:

	<div ng-controller="index">
		<input type="text" ng-model="message" />
		{{message}}
		<div ng-if="true">
			<input type="text" ng-model="message" />
			{{message}}
		</div>
	</div>

JavaScript:

	angular.module("root", [])
		.controller("index", ["$scope", function($scope) {
			$scope.message = "Hello World";
		}]);
        ]]>
      </Instructions>
      <Html>
        <Document Name="index.html">
          <Header>
            <![CDATA[
<!DOCTYPE html>
<html ng-app="root">
<body>
            ]]>
          </Header>
          <Initial>
            <![CDATA[
<div ng-controller="index">
	<div><input type="checkbox" ng-model="isFirstElementVisible" /> Is first element visible</div>
	<div><input type="checkbox" ng-model="isSecondElementVisible" /> Is second element visible</div>
	<div>First Element</div>
	<div>Second Element</div>
</div>
            ]]>
          </Initial>
          <Solution>
            <![CDATA[
<div ng-controller="index">
	<div><input type="checkbox" ng-model="isFirstElementVisible" /> Is first element visible</div>
	<div><input type="checkbox" ng-model="isSecondElementVisible" /> Is second element visible</div>
	<div ng-show="isFirstElementVisible">First Element</div>
	<div ng-if="isSecondElementVisible">Second Element</div>
</div>
            ]]>
          </Solution>
          <Footer>
            <![CDATA[
</body>
</html>
            ]]>
          </Footer>
        </Document>
      </Html>
      <JavaScript>
        <Document Name="root.js">
          <Initial>
            <![CDATA[
angular.module("root", [])
	.controller("index", ["$scope", function($scope) {
		$scope.isFirstElementVisible = true;
		$scope.isSecondElementVisible = true;
	}]);
            ]]>
          </Initial>
          <Solution>
            <![CDATA[
angular.module("root", [])
	.controller("index", ["$scope", function($scope) {
		$scope.isFirstElementVisible = true;
		$scope.isSecondElementVisible = true;
	}]);
            ]]>
          </Solution>
        </Document>
      </JavaScript>
    </Lesson>
  </Module>
  <Module Id="module-services" Title="Services">
    <Lesson Id="handling-complexity" Title="Handling Complexity">
      <Instructions>
        <![CDATA[
As Angular applications begin to grow bigger and more complex, the time inevitably comes when we want to externalize some of the logic contained in our controllers into outside objects. Angular provides us with two key features that work hand in hand to help us do just this: dependency injection and services.

###Dependency injection
Dependency injection is a central part of Angular application development. It is so central, in fact, that we have been using it since the very first example. Every time that we declare a controller with a `$scope` we are using Angular's internal dependency injection mechanism.

	.controller("index", ["$scope", function ($scope) {
		// $scope is dependency-injected!
	}]);

What is so special about this is that we do not invoke the controller function, passing it an argument. Angular does! Angular's injector sees from the `"$scope"` array element that we want the first (and only) function argument to be an instance of `$scope`, and Angular makes it so this is the case.*

###Services
In an Angular app, services are logical application components that are wired together using dependency injection. They allow us to externalize application logic out of controllers and encapsulate it in easy to use containers. Angular ships with a number of built-in services that allow us to do things like perform Ajax requests or change the URL in the browser's address bar, but the real power of services is the ability to write our own.

Angular defines five different service types, or "recipes". Each recipe results in a service which has special characteristics that make it useful for solving a certain type of problem. The following five lessons cover each one of these recipes in detail.

Ready to get started? 

---

*You may be wondering why we need this somewhat clumsy array syntax. Shouldn't Angular be able to detect that we want a `$scope` based on the name of the function argument? The reason why we use this syntax is because it allows the Angular injector to work properly when the JavaScript is minified. Minification alters variable names, but not strings.
        ]]>
      </Instructions>
    </Lesson>
    <Lesson Id="the-value-recipe" Title="The Value Recipe">
      <Instructions>
        <![CDATA[
The value recipe is the simplest service recipe of all. A value service does exactly what you would expect it to. It provides a value! While this may sound like a trivial feature, values play a key part in designing flexible, modular Angular applications.

The syntax for defining a value is very simple.

	angular.module("root", [])
		.value("message", "Hello world!");

Here we have defined a value called `message` which contains the string `"Hello world!"`.

We pass the `message` value to a controller in the exact same way as we pass a `$scope`. We add the `"message"` string to the controller array, and finish off by adding a corresponding argument to the controller function.

	angular.module("root", [])
		.value("message", "Hello world!")
		.controller("index", ["$scope", "message", function($scope, message) {
			// Do something with message and/or $scope.
		}]);
    
##Watch out!
		
There is one very important detail that we need to note before moving on. When Angular creates services, it creates them as singleton objects which are stored in a cache. When a service is injected into a method, the cached object is what is actually passed as an argument. This means that if your service returns a reference type, all methods which take the service as an argument will actually receive a reference to the **same object**. You must therefore be careful if you choose to modify the object, as the changes you make will be application-wide.*

##Modules
While the code above is well on its way to becoming a modular, extensible Angular app, we can actually take all this one step further. The AngularJS team recommends that applications be split into several modules, defined according to the following logic.

+ Create one module for each feature
+ Create one module for each reusable component
+ Create an application level module which depends on the above modules and contains any initialization code.

To make our application a bit more flexible, we can split it into two modules: one which will contain the value service, and one which will contain the controller.

	// Root.js
	angular.module("root", [])
		.controller("index", ["$scope", "message", function($scope, message) {
			// Do something with message and/or $scope.
		}]);

	// Services.js
	angular.module("services", [])
		.value("message", "Hello world!");

##More injection

The above code looks great. However, if we go ahead and run it, we will quickly see that we have a problem. The Angular dependency injector won't be able to inject the `message` service into the controller function. This is because by default the injector will not inject components defined in one module into components in another. More concretely, components defined in the `services` module are by default not available for use in the `root` module as far as the injector is concerned.

In order to tell the injector that we want to reference components from `services`, we need to inject the `services` module into the `root` module like so.

	// Root.js
	angular.module("root", ["services"])
		.controller("index", ["$scope", "message", function($scope, message) {
		// ...

Now, when the injector sees that we want to inject `message` into our controller function, it will look in the `services` module to see if it can find a match. Having to inject modules in this way is a great feature. Not only does it make it clear what a module depends on from the very first line of code, but it also helps prevent naming collisions.

##Example

For this example, try to replicate the code sample above, displaying the `message` in the HTML page provided by way of the `$scope`. You're pretty much on your own for this one. You have two empty .js files at your disposal, one for each module, and a bare HTML page where you will need to reference your controller *as well as your root module*. The exact steps you will need to take are as follows.

+ Declare a services module in `services.js` and create a value service named `message`.
+ Declare a root module in `root.js`, injecting your newly-created `services` module.
+ Create a controller in your root module. The controller should take a `$scope` and an instance of your `message` service.
+ Reference your root module in the HTML page.
+ Reference your controller in the HTML page.
+ Display the message on the page using the double curly brace syntax.

If you can complete this example successfully, you are well on your way to developing fully fledged Angular apps. If you have trouble, don't hesitate to click the "I'm Stuck!" button to see how it's done and try again.

---

*This isn't necessarily a bad thing. Not only does this behavior improve performance, but it also enables you to share data between controllers if need be.
        ]]>
      </Instructions>
      <Html>
        <Document Name="index.html">
          <Header></Header>
          <Initial>
            <![CDATA[
<html>
  <body>
    <div></div>
  </body>
</html>
            ]]>
          </Initial>
          <Solution>
            <![CDATA[
<html ng-app="root">
    <body>
        <div ng-controller="index">{{message}}</div>
    </body>
</html>
            ]]>
          </Solution>
          <Footer>
            <![CDATA[

            ]]>
          </Footer>
        </Document>
      </Html>
      <JavaScript>
        <Document Name="root.js">
          <Initial></Initial>
          <Solution>
            <![CDATA[
angular.module("root", ["services"])
	.controller("index", ["$scope", "message", function($scope, message) {
		$scope.message = message;
	}]);
            ]]>
          </Solution>
        </Document>
        <Document Name="services.js">
          <Initial></Initial>
          <Solution>
            <![CDATA[
angular.module("services", [])
	.value("message", "Hello world!");
            ]]>
          </Solution>
        </Document>
      </JavaScript>
    </Lesson>
    <Lesson Id="the-factory-recipe" Title="The Factory Recipe">
      <Instructions>
        <![CDATA[
Values are great, but wouldn't it be nice if we could inject a function instead of a variable? This is the purpose of the factory recipe. Factories are declared using the following syntax.

	angular.module("services", [])
		.factory("myFactory", [function () {
			// Logic goes here.
		}]);

We can also inject dependencies into a factory as we do with controllers.

	.factory("myFactory", ["dependency", function (dependency) {
		// ...

##Example

To demonstrate the use of the factory recipe, we're going to write an app which takes a number and squares it. To make things a bit more interesting, the number to square will be provided by a value service.

Let's start by defining our value service in a new module in `services.js`

	angular.module("services", [])
		.value("factor", 6);

Now let's create a "square" service which squares its argument, which will be the number retrieved from the `factor` service.

	angular.module("services", [])
		.value("factor", 6)
		.factory("square", ["factor", function (factor) {
				return factor * factor;
		}]);

Now let's add this logic to our controller and assign the result to the `product` variable. Don't forget to reference the `services` module!

	angular.module("root", ["services"])
		.controller("index", ["$scope", "square",
			function ($scope, square) {
				$scope.product = square;
			}
		]);

Notice how we use `square` as if it were a variable. We do not call it as if it were a function.

Let's finish off by turning our attention to the HTML. Reference the controller, and display `product` in the empty `<div>`.

	<div ng-controller="index">
		{{product}}
	</div>

We're all done. Run the program and try it out!
        ]]>
      </Instructions>
      <Html>
        <Document Name="index.html">
          <Header>
            <![CDATA[
<html ng-app="root">
<body>
            ]]>
          </Header>
          <Initial>
            <![CDATA[
<div>
</div>
            ]]>
          </Initial>
          <Solution>
            <![CDATA[
<div ng-controller="index">
	{{product}}
</div>
            ]]>
          </Solution>
          <Footer>
            <![CDATA[
</body>
</html>
            ]]>
          </Footer>
        </Document>
      </Html>
      <JavaScript>
        <Document Name="root.js">
          <Initial></Initial>
          <Solution>
            <![CDATA[
angular.module("root", ["services"])
	.controller("index", ["$scope", "square",
		function ($scope, square) {
			$scope.product = square;
		}
	]);
            ]]>
          </Solution>
        </Document>
        <Document Name="services.js">
          <Initial></Initial>
          <Solution>
            <![CDATA[
angular.module("services", [])
	.value("factor", 6)
	.factory("square", ["factor", function (factor) {
			return factor * factor;
	}]);
            ]]>
          </Solution>
        </Document>
      </JavaScript>
    </Lesson>
    <Lesson Id="the-service-recipe" Title="The Service Recipe">
      <Instructions>
        <![CDATA[
The service recipe is a step up from values and factories, in as much as it is used to expose objects. Its syntax looks like this.

	angular.module("services", [])
		.service("myService", ["dependency", MyObject]);

	// Declared elsewhere...
	function MyObject(dependency) {
		this.value = dependency.value;
	}

Note that this is equivalent to a factory which returns a `MyObject`.

	angular.module("services", [])
		.factory("myService", ["dependency", function (dependency) {
			return new MyObject(dependency);
		}]);

	// Declared elsewhere...
	function MyObject(dependency) {
		this.value = dependency.value;
	}
 
The real advantage of the service pattern is its cleaner syntax.

##Example

To practice using the service recipe we're going to expand on our example from the last lesson. Instead of writing a factory which squares a number, we're going to write a service which multiplies two numbers together. We'll display the result of the multiplication in our template.

The constructor for the object on which we'll base our service is already written for you in `multiplier.js`. It looks like this.

	function Multiplier(valueFactor) {
		this.multiply = function (controllerFactor) {
			return valueFactor * controllerFactor;
		};
	}

As you can see, it takes two numbers. One number is passed to the constructor, and the other is passed to the `multiply` function. As in the last example, we're going to inject the constructor argument by way of a value.

Let's go and add our service declaration to our `services` module. I've already declared the `factor` value for you. 

	angular.module("services", [])
		.value("factor", 6)
		.service("multiplier", ["factor", Multiplier]);

Time to write the controller. Declare a new controller on the `root` module. Inject the `multiplier` service as well as the `$scope`. Don't forget to inject `services` into the module declaration!

	angular.module("root", ["services"])
		.controller("index", ["$scope", "multiplier",
			function ($scope, multiplier) {
			}]);

Now, add the call to `multiply`, passing in the number of your choice. Assign the result to `$scope.product`.

	angular.module("root", ["services"])
		.controller("index", ["$scope", "multiplier",
			function ($scope, multiplier) {
				$scope.product = multiplier.multiply(2);
			}]);

To finish off, reference the controller in the template and display `product` in the empty `<div>`.

	<div ng-controller="index">{{product}}</div>

That's all we need to do. Launch the app and test it out!
        ]]>
      </Instructions>
      <Html>
        <Document Name="index.html">
          <Header>
            <![CDATA[
<html ng-app="root">
<body>
            ]]>
          </Header>
          <Initial>
            <![CDATA[
<div></div>
            ]]>
          </Initial>
          <Solution>
            <![CDATA[
<div ng-controller="index">{{product}}</div>
            ]]>
          </Solution>
          <Footer>
            <![CDATA[
</body>
</html>
            ]]>
          </Footer>
        </Document>
      </Html>
      <JavaScript>
        <Document Name="root.js">
          <Initial>
            <![CDATA[
angular.module("root", []);
            ]]>
          </Initial>
          <Solution>
            <![CDATA[
angular.module("root", ["services"])
	.controller("index", ["$scope", "multiplier",
		function ($scope, multiplier) {
			$scope.product = multiplier.multiply(2);
		}]);
            ]]>
          </Solution>
        </Document>
        <Document Name="services.js">
          <Initial>
            <![CDATA[
angular.module("services", [])
	.value("factor", 6)  
            ]]>
          </Initial>
          <Solution>
            <![CDATA[
angular.module("services", [])
	.value("factor", 6)
	.service("multiplier", ["factor", Multiplier]);
            ]]>
          </Solution>
        </Document>
        <Document Name="multiplier.js">
          <Initial>
            <![CDATA[
function Multiplier(valueFactor) {
	this.multiply = function (controllerFactor) {
		return valueFactor * controllerFactor;
	};
}
            ]]>
          </Initial>
          <Solution>
            <![CDATA[
function Multiplier(valueFactor) {
	this.multiply = function (controllerFactor) {
		return valueFactor * controllerFactor;
	};
}
            ]]>
          </Solution>
        </Document>
      </JavaScript>
    </Lesson>
    <Lesson Id="the-provider-recipe" Title="The Provider Recipe">
      <Instructions>
        <![CDATA[
Imagine that you have written an Angular service that can be used to retrieve weather data from a public API. The object returned by the service is as follows.

	{
		function Get3DayForecast(city, apiKey) {
			// Implementation
		}
	}

Now while this service may be quite handy, there is a point of redundancy in its design. Wouldn't it be nice to not have to pass the API key every time we want to make a call?

If this service was for our use only, we could simply embed the key directly in the object.

	{
		var apiKey = "A1B2C3";
		function Get3DayForecast(city) {
			// Implementation
		}
	}

However, if we wanted to share this service with others, this wouldn't be a very good solution. A better way would be to allow the consumer of the service to set the key once and for all before using it. This is what providers allow us to do.

##Example

###Defining the provider

The best way to see how providers work is through an example. Our example will be extremely simple. We are going to define a provider which will serve a `Message` object. The object is defined in `message.js` as follows.

	function Message(text) {
		this.text = text;
	}

The catch here is that, like the API key in the previous example, we will set the message text only once in our entire application. Every time we request a message, it will be returned to us with its text already set.

Let's look at the code which will allow us to do this. Add this code to the `services` module definition in `services.js`.

	.provider("message", [function () {
		var text = null;

		this.setText = function (textString) {
			text = textString;
		};

		this.$get = [function () {
			return new Message(text);
		}];
	}]);

Let's look at what's going on here. The first thing that we have is a `text` variable. This will hold the text that will be used to instantiate our `Message`.

The second thing that we have is a function called `setText`. `setText` is the function that we will call to configure our provider. We will pass it a string that will be stored in the `text` variable, only to be finally be used in the call to the `Message()` constructor.

Finally, we have a method called `$get`. As you probably have imagined due to the leading `$`, `$get` is a function that has a special meaning for Angular. When we inject our provider into a function by way of the provider name (`"message"`), Angular will call `$get` to retrieve the object to inject. In this case, it will inject a `Message` that has been instantiated with `text`.

###Using the provider

Now that our provider is defined, let's use it to display a message in our page. Let's start by configuring our provider. We do this like so.

	angular.module("root", ["services"])
		.config(["messageProvider", function (messageProvider) {
			messageProvider.setText("Hello world!");
		}])

This syntax is fairly easy to understand. We call `setText`, in the `config()` function, passing in the message that we want to instantiate our `Message` object with. The only thing that might seem out of place is the `"messageProvider"` string. Where did it come from, and why are we injecting `"messageProvider"` into `config()` and not `"message"` instead?

The reason is because `"message"` does not refer to the object that we defined in the call to `provider()`. `"message"` refers the object defined by the provider's `$get` function. In order to inject the object defined in the provider call, on which we declared the `setText()` function, we inject `"messageProvider"`. 

To be clear, we did not define what `"messageProvider"` meant anywhere in our code. It is simply Angular convention that `"[provider name]Provider"` refers to the provider function result, and that `"[provider name]"` refers to the `$get` result.

Now that our provider is configured to return a `Message` whose `text` is set to `"Hello world!"`, the only thing left to do is inject an instance of it into our controller function and display the result.

	angular.module("root", ["services"])
		.config(["messageProvider", function (messageProvider) {
			messageProvider.setText("Hello world!");
		}])
		.controller("index", ["$scope", "message",
			function ($scope, message) {
				$scope.message = message.text;
			}
		]);

When run, the app should display "Hello world!" onscreen.
        ]]>
      </Instructions>
      <Html>
        <Document Name="index.html">
          <Header>
            <![CDATA[
<html ng-app="root">
<body>
            ]]>
          </Header>
          <Initial>
            <![CDATA[
<div ng-controller="index">{{message}}</div>
            ]]>
          </Initial>
          <Solution>
            <![CDATA[
<div ng-controller="index">{{message}}</div>
            ]]>
          </Solution>
          <Footer>
            <![CDATA[
</body>
</html>
            ]]>
          </Footer>
        </Document>
      </Html>
      <JavaScript>
        <Document Name="root.js">
          <Initial>
            <![CDATA[
angular.module("root", ["services"])
            ]]>
          </Initial>
          <Solution>
            <![CDATA[
angular.module("root", ["services"])
	.config(["messageProvider", function (messageProvider) {
		messageProvider.setText("Hello world!");
	}])
	.controller("index", ["$scope", "message",
		function ($scope, message) {
			$scope.message = message.text;
		}]);
            ]]>
          </Solution>
        </Document>
        <Document Name="services.js">
          <Initial>
            <![CDATA[
angular.module("services", [])
            ]]>
          </Initial>
          <Solution>
            <![CDATA[
angular.module("services", [])
	.provider("message", [function () {
		var text = null;

		this.setText = function (textString) {
			text = textString;
		};

		this.$get = [function () {
			return new Message(text);
		}];
	}]);
            ]]>
          </Solution>
        </Document>
        <Document Name="message.js">
          <Initial>
            <![CDATA[
function Message(text) {
	this.text = text;
}
            ]]>
          </Initial>
          <Solution>
            <![CDATA[
function Message(text) {
	this.text = text;
}
            ]]>
          </Solution>
        </Document>
      </JavaScript>
    </Lesson>
    <Lesson Id="the-constant-recipe" Title="The Constant Recipe">
      <Instructions>
        <![CDATA[
In the last lesson, we saw how providers can be configured using the `config` function. In the example app that we coded, the `config` call looked like this.

	.config(["messageProvider", function (messageProvider) {
			messageProvider.setText("Hello world!");
	}])

This worked well for our example. However, we can easily imagine a scenario when we would rather inject `"Hello world!"` instead of hardcoding it into the function.

If you were to try to attempt this, you might try defining a value service and injecting it into the `config` function.

	.value("messageText", "Hello world!");

However you would soon realize that this doesn't work.

The reason why is that `config()` functions are executed before services are instantiated and registered with Angular. This makes sense, because the whole purpose of `config()` functions is to modify the behavior of services. As a result, you cannot inject a value service into a `config()` function because, as far as Angular is concerned, it doesn't exist yet!

This is the problem that constants solve. Constants are defined during the configuration phase of an Angular application. This means that, unlike other services, they *can* be injected into `config()` functions. The syntax for defining constants is just like the syntax for defining values.

	.constant("messageText", "Hello world!");

##Example

The starting code in the editors is the exact same code that we wrote in the lesson on providers. For this example, try creating a constant called `messageText` containing the string `"Hello constant!"` and injecting it into the `config()` function to instantiate the message object. Like in the providers example, `Hello constant!` should be displayed onscreen once you are done.
        ]]>
      </Instructions>
      <Html>
        <Document Name="index.html">
          <Header>
            <![CDATA[
<html ng-app="root">
<body>
            ]]>
          </Header>
          <Initial>
            <![CDATA[
<div ng-controller="index">{{message}}</div>
            ]]>
          </Initial>
          <Solution>
            <![CDATA[
<div ng-controller="index">{{message}}</div>
            ]]>
          </Solution>
          <Footer>
            <![CDATA[
</body>
</html>
            ]]>
          </Footer>
        </Document>
      </Html>
      <JavaScript>
        <Document Name="root.js">
          <Initial>
            <![CDATA[
angular.module("root", ["services"])
	.config(["messageProvider", function (messageProvider) {
		messageProvider.setText("Hello world!");
	}])
	.controller("index", ["$scope", "message",
		function ($scope, message) {
			$scope.message = message.text;
		}]);
            ]]>
          </Initial>
          <Solution>
            <![CDATA[
angular.module("root", ["services"])
	.config(["messageProvider", "messageText",
		function (messageProvider, messageText) {
			messageProvider.setText(messageText);
		}])
	.controller("index", ["$scope", "message",
		function ($scope, message) {
			$scope.message = message.text;
		}]);
            ]]>
          </Solution>
        </Document>
        <Document Name="services.js">
          <Initial>
            <![CDATA[
angular.module("services", [])
	.provider("message", [function () {
		var text = null;

		this.setText = function (textString) {
			text = textString;
		};

		this.$get = [function () {
			return new Message(text);
		}];
	}]);
            ]]>
          </Initial>
          <Solution>
            <![CDATA[
angular.module("services", [])
	.constant("messageText", "Hello constant!")
	.provider("message", [function () {
		var text = null;

		this.setText = function (textString) {
			text = textString;
		};

		this.$get = [function () {
			return new Message(text);
		}];
	}]);
            ]]>
          </Solution>
        </Document>
        <Document Name="message.js">
          <Initial>
            <![CDATA[
function Message(text) {
	this.text = text;
}
            ]]>
          </Initial>
          <Solution>
            <![CDATA[
function Message(text) {
	this.text = text;
}
            ]]>
          </Solution>
        </Document>
      </JavaScript>
    </Lesson>
  </Module>
  <Module Id="module-enriching-applications" Title="Enriching Applications">
    <Lesson Id="watch" Title="$watch">
      <Instructions>
        <![CDATA[
Take a look at the code in the editors. You'll see that the user interface contains a textbox in which is entered the number 6, and that the value of the textbox is bound to the variable `$scope.factor`. Beside the textbox is displayed `$scope.product`, which is calculated in the controller function as `$scope.factor * 2`.

Try running this code. Everything displays normally, with the textbox containing the number 6 by default and the number 12 being displayed beside it. Now try modifying the value in the textbox. You may be surprised to see that `$scope.product` is not updated!

##But why?
The reason why this happens is because `$scope.product` is initialized to the value returned by `$scope.factor * 2` when the model is augmented by the controller. It is *not* initialized to the result of the function *throughout the program's execution*. When `$scope.factor` is changed, there is no mechanism in place to update `$scope.product` accordingly.

##An overview of $watch
This is where the `$watch` function comes in. `$watch` provides us with a way to keep calculated values up to date when the values that they depend on change. The syntax for `$watch` looks like this.

	$scope.$watch([expression returning watched value],
				  [change handler],
				  [objectEquality?]);

Let's clarify this a bit. The first argument basically points to the value to watch. This can be a string containing the name of a variable in scope, or a function that returns the variable itself.

The second argument takes a function that looks like this.

	function (newValue, oldValue) {
		// Take action.
	}

This is where the actual work gets done. In our example, this is where we would update `$scope.product` based on the value of `newValue`.

The third argument is a boolean value which, when set to true, compares objects for equality rather than reference. This argument can be, and is often, omitted instead of being set to `false`.

##Example

Now it's up to you to pick up where I left off. Use a `$watch` expression to update `$scope.product` when the value in the textbox is changed. Specifically, you will need to watch `$scope.factor` and set `$scope.product` to 2 times `factor` whenever `factor` is changed.
        ]]>
      </Instructions>
      <Html>
        <Document Name="index.html">
          <Header>
            <![CDATA[
<html ng-app="root">
<body>
            ]]>
          </Header>
          <Initial>
            <![CDATA[
<div ng-controller="index">
	<input type="text" ng-model="factor" /> {{product}}
</div>
            ]]>
          </Initial>
          <Solution>
            <![CDATA[
<div ng-controller="index">
	<input type="text" ng-model="factor" /> {{product}}
</div>
            ]]>
          </Solution>
          <Footer>
            <![CDATA[
</body>
</html>
            ]]>
          </Footer>
        </Document>
      </Html>
      <JavaScript>
        <Document Name="root.js">
          <Initial>
            <![CDATA[
angular.module("root", [])
	.controller("index", ["$scope", function($scope) {
		$scope.factor = 6;
		$scope.product = $scope.factor * 2;
	}]);
            ]]>
          </Initial>
          <Solution>
            <![CDATA[
angular.module("root", [])
	.controller("index", ["$scope", function($scope) {
		$scope.$watch("factor", function (newValue) {
			$scope.product = newValue * 2;
		});

		$scope.factor = 6;
	}]);
            ]]>
          </Solution>
        </Document>
      </JavaScript>
    </Lesson>
    <Lesson Id="filters" Title="Filters">
      <Instructions>
        <![CDATA[
Simply put, filters are functions which transform one value into another. They are commonly used in two different scenarios.

+ To transform a value for display purposes. For example, taking the number 6 and transforming it into $6.00 could be accomplished very easily with the help of a filter.
+ To filter collections. A filter could be written to take an array of names and return a smaller array, filtered based on a condition provided by the user.

##Syntax

A filter is declared using the `filter` method. The method takes two arguments: A name, and a function which returns the function that will actually do the filtering. This is important to remember. It isn't the function passed to the `filter` method which does the filtering, but the function *returned* by the function passed to the method.

This is what a filter definition looks like.

	angular.module("root", [])
		.filter("doSomething", function () {
			return function(input) {
				// Transform the input and return a value.
			}
		});

The function which does the filtering can take as many arguments as desired, however the first one is always reserved for the input.

Filters can be used in controllers or in views. To use a filter in a controller you simply inject it as you would any other component. There is one small catch, however. You must append "Filter" to the filter name when specifying it for the injector. Therefore, to inject the `doSomething` filter defined above into a controller, the following syntax is required.

	.controller("index", ["doSomethingFilter", function(filter) {
			// ...
		});

Using a filter in a view is a little bit different. We'll learn how to do this by way of an example.

##Example

For this example we are going to define a filter which will round a numerical value to a certain number of decimal places.

Let's start by defining the filter in `filters.js`.

	angular.module("filters", [])
		.filter("round", function () {
			return function(input, precision) {
				return input ?
					parseFloat(input).toFixed(precision) :
					"";
			};
		});

Notice how we are making this filter more flexible by allowing the user to specify a precision.

Now let's integrate this filter into our view. For the moment our view contains a single text box whose value maps to the `$scope.value` variable. Let's modify our template to output `$scope.value` directly onto the page.

	<p>Value: <input type="text" ng-model="value" /></p>
	<p>{{value}}</p>

Now let's apply the filter. To apply a filter to a value in a template we use the following syntax.

	{{ expression | filter:arg1:arg2... }}

For the sake of this example let's say that we want to round our value to two decimal places. We therefore need to replace `{{value}}` with the following.

	{{value | round:2}}

That's all we need to do. Go ahead and try it out.

###Chaining filters

Let's define another filter which will prepend `$` to our rounded number. Add this definition to `filters.js` right after the `round` filter.

	.filter("dollars", function () {
		return function(input) {
			return input ? "$" + input : "";
		};
	});

Now let's integrate this into our template. Angular lets us chain filters together by using a `|`. Therefore, to chain our `dollars` filter to our `round` filter, we use the following syntax.

	{{value | round:2 | dollars}}

Note that the order is important in this case. We want to round our number before applying the `$` to it, not after.

That's it! Now when we enter a numerical value into the textbox it is transformed by our filters into its monetary equivalent.
        ]]>
      </Instructions>
      <Html>
        <Document Name="index.html">
          <Header>
            <![CDATA[
<html ng-app="root">
<body>
            ]]>
          </Header>
          <Initial>
            <![CDATA[
<div ng-controller="index">
	<p>Value: <input type="text" ng-model="value" /></p>
</div>
            ]]>
          </Initial>
          <Solution>
            <![CDATA[
<div ng-controller="index">
	<p>Value: <input type="text" ng-model="value" /></p>
  <p>{{value | round:2 | dollars}}</p>
</div>
            ]]>
          </Solution>
          <Footer>
            <![CDATA[
</body>
</html>
            ]]>
          </Footer>
        </Document>
      </Html>
      <JavaScript>
        <Document Name="root.js">
          <Initial>
            <![CDATA[
angular.module("root", ["filters"])
	.controller("index", [function() {}]);
            ]]>
          </Initial>
          <Solution>
            <![CDATA[
angular.module("root", ["filters"])
	.controller("index", [function() {}]);
            ]]>
          </Solution>
        </Document>
        <Document Name="filters.js">
          <Initial>
            <![CDATA[
angular.module("filters", [])
            ]]>
          </Initial>
          <Solution>
            <![CDATA[
angular.module("filters", [])
	.filter("round", function () {
		return function(input, precision) {
			return input ?
				parseFloat(input).toFixed(precision) :
				"";
		};
	})
	.filter("dollars", function () {
		return function(input) {
			return input ? "$" + input : "";
		};
	});
            ]]>
          </Solution>
        </Document>
      </JavaScript>
    </Lesson>
    <Lesson Id="data-validation" Title="Data Validation">
      <Instructions>
        <![CDATA[
Form validation is a key component of all but the simplest of web applications. AngularJS once again has us covered by providing a built in framework to tell users whether or not the data they have entered into a form is valid. It does this by applying a subset of the following four CSS classes.

+ `ng-valid`
+ `ng-invalid`
+ `ng-pristine`
+ `ng-dirty`

As developers, we can then go ahead and write CSS rules to apply different styles to fields and forms depending on their state.

## Defining validity

The CSS classes that Angular exposes are extremely useful, but in order to use them we need to tell Angular how to actually validate our data. For this, Angular relies on HTML5's data validation framework. We won't get into the details of HTML5 data validation here, but if you are interested in what it has to offer [this is a great place to start](https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/HTML5/Constraint_validation).

## Example

For this example we are going to validate the two input fields defined in the form in our template. We are going to do this by applying the following validation logic.

+ The name field is required.
+ The email field is optional, but must be a valid email if provided.

In addition to this, we will apply the following design guidelines.

+ Fields must only be styled if they have been touched by the user.
+ Fields must be styled with a green border when vaild.
+ Fields must be styled with a red border when invalid.
+ The form itself must not be styled in any way.

Let's get coding. The first thing that we need to do is map a `$scope` value to each form field. The names don't matter much because we're not really going to submit this data, but Angular won't validate fields that aren't mapped to the `$scope` so this is a logical first step to take.

	<input type="text" ng-model="name" />
	<input type="text" ng-model="email" />

Now let's write our styles. Remember our design guidelines. Fields that are dirty and valid get a green border, and those which are dirty and invalid get a red border. Clean fields don't get styled. We also need to explicitly state that we want to style `input` tags, because we don't want our `form` getting styled as well.

	input.ng-dirty.ng-valid {
		border-color: green;
	}
	
	input.ng-dirty.ng-invalid {
		border-color: red;
	}

Excellent. All we have left to do is apply our validation logic. Let's start by making the name field mandatory by adding the `required` boolean attribute to it.

	<input type="text" ng-model="name" required />

Now let's require that the value of the email field actually be a valid email address. We do this by changing the `type` of the input from `text` to `email`.

	<input type="email" ng-model="email" />

Now run the code and try playing with the values in each of the different fields. The border of each field should change depending on whether data has been entered into it and whether the data it contains is valid according to the rules we have defined.

---

*Note: This probably goes without saying for many visitors to this site, but Angular data validation is a client-side validation solution. It is critical that all data submitted to a web application, including those validated on the client, be validated on the server.*
        ]]>
      </Instructions>
      <Html>
        <Document Name="index.html">
          <Header>
            <![CDATA[
<html ng-app="root">
<body>
            ]]>
          </Header>
          <Initial>
            <![CDATA[
<style>
/* Write your style rules here */
</style>

<form ng-controller="index">
	<p>Name: <input type="text" /></p>
	<p>Email: <input type="text" /></p>
</form>
            ]]>
          </Initial>
          <Solution>
            <![CDATA[
<style>
	input.ng-dirty.ng-valid {
		border-color: green;
	}
	
	input.ng-dirty.ng-invalid {
		border-color: red;
	}
</style>

<form ng-controller="index">
	<p>Name: <input type="text" ng-model="name" required /></p>
	<p>Email: <input type="email" ng-model="email" /></p>
</form>
            ]]>
          </Solution>
          <Footer>
            <![CDATA[
</body>
</html>
            ]]>
          </Footer>
        </Document>
      </Html>
      <JavaScript>
        <Document Name="root.js">
          <Initial>
            <![CDATA[
angular.module("root", [])
	.controller("index", [function() {}]);
            ]]>
          </Initial>
          <Solution>
            <![CDATA[
angular.module("root", [])
	.controller("index", [function() {}]);
            ]]>
          </Solution>
        </Document>
      </JavaScript>
    </Lesson>
    <Lesson Id="ajax-with-resource" Title="Ajax with $resource">
      <Instructions>
        <![CDATA[
Ajax calls are an integral part of virtually all modern web applications. Once again, Angular doesn't disappoint and gives us not one but two different APIs to handle Ajax requests. In this lesson we're going to look at the higher-level of the two, which is known as `$resource`.

## Introduction to $resource

As mentioned a moment ago, `$resource` is a high-level Ajax API. Instead of providing fine-grained control over how requests are made, `$resource` makes a number of assumptions about how a web service endpoint should function, and with minimal information from the developer constructs an object that can be used to make a wide variety of requests to the service.

## The basics

The best way to understand how `$resource` works is by seeing how a resource object is made and what it is capable of. At its simplest, we can instantiate one using the following code.

	var resourceObject = $resource(url);   

This may not look like much, but believe it or not `resourceObject` already contains the following functions.

+ `get([params], [success], [error])` - Makes a standard GET call.
+ `save([params], postData, [success], [error])` - Makes a standard POST call.
+ `query([params], [success], [error])` - Makes a standard GET call and returns the response as an array.
+ `remove([params], postData, [success], [error])` - Makes a standard DELETE call.

Let's briefly run through the arguments to these methods. `success` and `error` are both callback functions that will execute in their respective cases. No surprises there. `postData`, where applicable, is simply the data to post to the server. Again, no surprises.

What might be a little less clear is the purpose of the `params` argument. To understand what it is used for, we first must go back to our initial `$resource` call. As we saw a moment ago, the minimum amount of data required to create a `$request` object is a URL. However this url can contain placeholders for parameter values which can then be replaced when Ajax calls are made. Placeholders are integrated into URLs as follows.

	`http://www.mysite.com/users/:paramName`  

If we were making a `GET` request using a resource object configured for this URL and wanted to set a value for `paramName`, all we would have to do is pass the following object as the first argument to the object's `get` method.

	{ paramName: value }

With these four methods and the features they provide, CRUD requests between client and server become effortless to configure and execute. But there's more! When a resource object receives a response from the server it automatically deserializes the response into a JavaScript object, appending the following two methods to it in the process.

+ `$save([params], [success], [error])` - POSTs the object back to the endpoint, saving changes
+ `$remove([params], [success], [error])` - DELETEs the object

Note that these are essentially the same methods that exist on the `$resource` object, except that they do not take a `postData` parameter. These methods are actually customized for the object on which they are configured. That means that if you modify an object and then call `$save`, the object will be serialized and POSTed to the server where it can be updated. The same goes for `$remove`, which makes a DELETE request instead. This really is an amazing feature that saves a lot of time and effort on the part of the developer.

## Example

For this example we're going to use `$resource` to create a service which will perform the following two actions.

1. Retrieve a fictitious "user" from a RESTful endpoint.
2. POST a modified version of the user back to the endpoint.

As this lesson really is about using the `$resource` API, everything unrelated to `$resource` has already been taken care of. We start out with a basic HTML interface that contains two fields, one for a name and one for an email. It also contains a button to retrieve the user from the RESTful endpoint and a button to save it back. Our goal for this lesson will be to fill in the `getUser` and `postUser` functions attached to these two buttons to make this interface truly functional.

### Configuration

Before we can even get to using `$resource`, a bit of configuration is required. The first thing to take into account is that `$resource` is not a part of the core AngularJS API. The Angular team has instead decided to include `$resource` in a separate module, in a separate code file. For this example the code file has been automatically included, but if you use `$resource` in your own applications you will naturally need to add a reference to it yourself. The name of the file to include is `angular-resource[.min].js`. The file can be downloaded on the AngularJS website, or referenced directly off the Google CDN.

As `$resource` lives in its own module, we need to inject this module into our own. To do this, add `"ngResource"` to the empty array in the module declaration function.

Now, inject `$resource` into the controller by adding it to the `controller` call, both as a dependency and as a controller function argument.

	.controller("index", ["$scope", "$resource", function($scope, $resource) {

That's all we need to do. Now let's start using it! 

### Code

We'll start out by defining our resource object. As we're going to use it in both the `getUser` and `postUser` methods we need to define it directly in the controller function. The URL to the endpoint is as follows.

	http://www.learn-angular.org/ResourceLesson/Users/

In order to retrieve a given user from the server, our RESTful service requires that we append an ID to the end of the URL. Our service will return the user corresponding to the ID that we provide. We'll implement this ID integration into the url using a placeholder, as follows.

	http://www.learn-angular.org/ResourceLesson/Users/:id

Let's now go ahead and use this url to instantiate the resource object. 

	var users = $resource("http://www.learn-angular.org/ResourceLesson/Users/:id");

Now we'll implement our `get` function. The web service listening at the url provided contains a dummy user with the ID of `1`. Therefore to retrieve this user and bind it to our model we need to add the following line of code to the function body.
	 
	$scope.user = users.get({id: 1});

When executed, this line of code will insert `1` into our request URL, send off the GET request to the server, deserialize the returned data into a JavaScript object, and assign it to the `$scope.user` variable. The name and email fields in our HTML are preconfigured to bind to the name and email fields on the object returned by the web service.

Now let's implement our save function. Because we will be saving a user that we have already retrieved from the web service, this task is extremely simple. All we need to do is call the `$save()` method that Angular has attached to the user object for us. Add the following code to the `postUser` function.

	var response = $scope.user.$save(function () {
		alert("User saved!");
	});

Here we've simply passed a callback which will alert us if the user has been saved successfully.

That's all we need to do. Run the code and try the following.

1. Click the "Get User" button. The two form fields should fill up with dummy user data.
2. Modify the data and click the "Post User" button. The callback that you passed to the `$save` method should execute and an alert should pop up onscreen indicating that the user has been saved.
3. Clear the form fields and click the "Get User" button once again. The fields should fill with the data that you saved a moment ago.

## $resource on the server

Because `$resource` makes many assumptions about how a web service endpoint should function, it often proves to be the most useful when you are the one who is in control of the web service. If you are writing a web service to use with `$resource`, keep the following guidelines in mind.

+ The service should be RESTful. The action that the server-side code should take should be determined by the HTTP verb used in the request.
+ The same url should be used for all requests. Parameter segments or querystring arguments can be added for GET requests.
+ JSON should be used as the preferred serialization standard. As we saw earlier, Angular will automatically deserialize JSON responses into objects without any additional action on your part.

## More about $resource...

`$resource` is an extremely powerful API. While in this lesson we have been able to walk through the basics, `$resource` contains many more features than could reasonably be covered here. These features include:

+ Custom request methods
+ Default parameter values
+ Custom (de)serialization logic
+ Cache support
+ and much more...

[The entire feature set is documented here](https://docs.angularjs.org/api/ngResource/service/$resource) in the AngularJS API reference. I strongly encourage you to take a moment and check it out.
        ]]>
      </Instructions>
      <Html>
        <Document Name="index.html">
          <Header>
            <![CDATA[
<html ng-app="root">
<body>
            ]]>
          </Header>
          <Initial>
            <![CDATA[
<div ng-controller="index">
	<button ng-click="getUser()">Get User</button>
	Name: <input ng-model="user.name" />
	Email: <input ng-model="user.email" />
	<button ng-click="postUser()">Post User</button>
</div>
            ]]>
          </Initial>
          <Solution>
            <![CDATA[
<div ng-controller="index">
	<button ng-click="getUser()">Get User</button>
	Name: <input ng-model="user.name" />
	Email: <input ng-model="user.email" />
	<button ng-click="postUser()">Post User</button>
</div>
            ]]>
          </Solution>
          <Footer>
            <![CDATA[
</body>
</html>
            ]]>
          </Footer>
        </Document>
      </Html>
      <ScriptIncludes>
        <Include>
          <![CDATA[
<script src="/Scripts/angular/angular-resource.min.js"></script>
          ]]>
        </Include>
      </ScriptIncludes>
      <JavaScript>
        <Document Name="root.js">
          <Initial>
            <![CDATA[
angular.module("root", [])
	.controller("index", ["$scope", function($scope) {		
		$scope.getUser = function () {
			// Make a GET call and store the result in user.
		};

		$scope.postUser = function () {
			// Save the user and alert on success or failure.
		};
	}]);
            ]]>
          </Initial>
          <Solution>
            <![CDATA[
angular.module("root", ["ngResource"])
	.controller("index", ["$scope", "$resource", function($scope, $resource) {
		var users = $resource("http://www.learn-angular.org/ResourceLesson/Users/:id");
		
		$scope.getUser = function () {
			$scope.user = users.get({id: 1});
		};

		$scope.postUser = function () {
			var response = $scope.user.$save(function () {
				alert("User saved!");
			});
		};
	}]);
            ]]>
          </Solution>
        </Document>
      </JavaScript>
    </Lesson>
  </Module>
  <!--<Module Id="" Title="Test Module">
    <Lesson Id="" Title="Empty Lesson">
      <Instructions>
        <![CDATA[

        ]]>
      </Instructions>
      <Html>
        <Document Name="index.html">
          <Header>
            <![CDATA[

            ]]>
          </Header>
          <Initial>
            <![CDATA[

            ]]>
          </Initial>
          <Solution>
            <![CDATA[

            ]]>
          </Solution>
          <Footer>
            <![CDATA[

            ]]>
          </Footer>
        </Document>
      </Html>
      <JavaScript>
        <Document Name="root.js">
          <Initial>
            <![CDATA[

            ]]>
          </Initial>
          <Solution>
            <![CDATA[

            ]]>
          </Solution>
        </Document>
      </JavaScript>
    </Lesson>
  </Module>-->
</Course>
